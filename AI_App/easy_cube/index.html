<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Easy Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
    <script type="module" src="https://pyscript.net/latest/pyscript.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.165.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body class="min-h-screen bg-gray-900 text-gray-100">
    <div class="max-w-7xl mx-auto p-4 space-y-4">
      <header class="flex items-center justify-between">
        <h1 class="text-xl font-semibold">Easy Cube</h1>
      </header>

      <section class="bg-gray-800/60 rounded-lg p-4 shadow">
        <div class="flex flex-wrap gap-3 items-end">
          <label for="cubeCount" class="block">
            <span class="block text-sm mb-1">输入立方体数量</span>
            <input
              id="cubeCount"
              type="number"
              min="1"
              value="8"
              aria-label="输入立方体数量"
              tabindex="0"
              class="px-3 py-2 rounded border border-gray-700 bg-gray-900 focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
          </label>
          <button
            id="btnGenerate"
            aria-label="生成立方体"
            tabindex="0"
            class="px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-500 focus:ring-2 focus:ring-indigo-400"
          >
            生成
          </button>
          <button
            id="btnArrange"
            aria-label="还原到默认位置"
            tabindex="0"
            class="px-4 py-2 rounded bg-teal-600 hover:bg-teal-500 focus:ring-2 focus:ring-teal-400"
          >
            还原位置
          </button>
          <span id="status" class="text-sm text-gray-400">准备就绪</span>
        </div>
      </section>

      <section class="relative bg-gray-800/60 rounded-lg shadow overflow-hidden">
        <div id="canvas-container" class="w-full h-[640px]" aria-label="三维画布" tabindex="0"></div>
      </section>
    </div>

    <py-config>
    </py-config>
    <py-script src="AI_cube.py"></py-script>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      const container = document.getElementById("canvas-container");
      const statusEl = document.getElementById("status");
      const btnGenerate = document.getElementById("btnGenerate");
      const btnArrange = document.getElementById("btnArrange");
      const inputN = document.getElementById("cubeCount");

      let scene, camera, renderer, controls, raycaster;
      let dragging = false;
      let selected = null;
      let dragPlane = new THREE.Plane();
      const pointer = new THREE.Vector2();
      const offset = new THREE.Vector3();
      const intersectPoint = new THREE.Vector3();
      const UNIT_SIZE = 1;

      let cubes = [];
      let cubeEdges = [];
      let blockOutline = null;
      let ground;
      let defaultPositions = []; // 保存默认位置

      const setStatus = (msg) => {
        statusEl.textContent = msg;
      };

      const initScene = () => {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f172a); // slate-900

        const aspect = container.clientWidth / container.clientHeight;
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        camera.position.set(6, 6, 8);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.target.set(0, 0.5, 0);

        // Lights
        const ambi = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(5, 8, 4);
        dir.castShadow = true;
        dir.shadow.mapSize.set(1024, 1024);
        scene.add(dir);

        // Ground to receive shadows
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x111827, // gray-900
          roughness: 1,
          metalness: 0,
        });
        ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // Grid
        const grid = new THREE.GridHelper(40, 40, 0x374151, 0x1f2937); // gray-700/800 lines
        scene.add(grid);

        // Raycaster
        raycaster = new THREE.Raycaster();

        window.addEventListener("resize", handleResize);
        renderer.domElement.addEventListener("pointerdown", handlePointerDown);
        renderer.domElement.addEventListener("pointermove", handlePointerMove);
        renderer.domElement.addEventListener("pointerup", handlePointerUp);
        renderer.domElement.addEventListener("pointerleave", handlePointerUp);
        renderer.domElement.addEventListener("wheel", handleWheel, { passive: false });

        animate();
      };

      const handleResize = () => {
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      };

      const getIntersects = (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        return raycaster.intersectObjects(cubes, false);
      };

      const handlePointerDown = (event) => {
        const intersects = getIntersects(event);
        if (!intersects.length) return;
        selected = intersects[0].object;
        dragging = true;
        controls.enabled = false;
        // 使用相机朝向作为拖拽平面法向量，支持三轴移动
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        const d = -cameraDirection.dot(selected.position);
        dragPlane.set(cameraDirection, d);
        raycaster.ray.intersectPlane(dragPlane, intersectPoint);
        offset.copy(intersectPoint).sub(selected.position);
      };

      const handlePointerMove = (event) => {
        if (!dragging || !selected) return;
        raycaster.setFromCamera(updatePointer(event), camera);
        if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
          const desired = intersectPoint.sub(offset);
          // 支持同时在X、Y、Z轴移动，每次移动间隔固定为UNIT_SIZE
          let snapX = Math.round(desired.x / UNIT_SIZE) * UNIT_SIZE;
          let snapY = Math.round(desired.y / UNIT_SIZE) * UNIT_SIZE;
          let snapZ = Math.round(desired.z / UNIT_SIZE) * UNIT_SIZE;
          
          // 添加吸附对齐效果：当靠近其他立方体时自动对齐
          const snapThreshold = UNIT_SIZE * 0.3; // 吸附阈值
          cubes.forEach((cube) => {
            if (cube === selected) return;
            
            // X轴吸附
            const dx = Math.abs(cube.position.x - desired.x);
            if (dx < snapThreshold) {
              snapX = cube.position.x;
            }
            
            // Y轴吸附（允许堆叠）
            const dy = Math.abs(cube.position.y - desired.y);
            if (dy < snapThreshold) {
              snapY = cube.position.y;
            } else if (Math.abs(cube.position.y + UNIT_SIZE - desired.y) < snapThreshold) {
              // 堆叠在上方
              snapY = cube.position.y + UNIT_SIZE;
            } else if (Math.abs(cube.position.y - UNIT_SIZE - desired.y) < snapThreshold) {
              // 堆叠在下方
              snapY = cube.position.y - UNIT_SIZE;
            }
            
            // Z轴吸附
            const dz = Math.abs(cube.position.z - desired.z);
            if (dz < snapThreshold) {
              snapZ = cube.position.z;
            }
          });
          
          selected.position.set(snapX, snapY, snapZ);
        }
      };

      const updatePointer = (event) => {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        return pointer;
      };

      const handlePointerUp = () => {
        if (!dragging || !selected) {
          dragging = false;
          controls.enabled = true;
          return;
        }
        dragging = false;
        controls.enabled = true;
        if (window.pySnap) {
          const arr = window.pySnap(selected.position.x, selected.position.y, selected.position.z, UNIT_SIZE);
          const snapped = arr?.toJs ? arr.toJs() : arr;
          if (Array.isArray(snapped) && snapped.length === 3) {
            selected.position.set(snapped[0], snapped[1], snapped[2]);
          }
        } else {
          // fallback: local snap
          selected.position.x = Math.round(selected.position.x / UNIT_SIZE) * UNIT_SIZE;
          selected.position.y = Math.round(selected.position.y / UNIT_SIZE) * UNIT_SIZE;
          selected.position.z = Math.round(selected.position.z / UNIT_SIZE) * UNIT_SIZE;
        }
        updateBlockOutline();
        selected = null;
      };

      const handleWheel = (event) => {
        if (!selected) return;
        event.preventDefault();
        // 滚轮移动时也固定为UNIT_SIZE，并添加吸附效果
        const dir = Math.sign(event.deltaY);
        const newY = selected.position.y - dir * UNIT_SIZE;
        
        // 检查是否有其他立方体在目标位置
        let finalY = newY;
        const snapThreshold = UNIT_SIZE * 0.3;
        cubes.forEach((cube) => {
          if (cube === selected) return;
          if (Math.abs(cube.position.y - newY) < snapThreshold && 
              Math.abs(cube.position.x - selected.position.x) < UNIT_SIZE * 0.5 &&
              Math.abs(cube.position.z - selected.position.z) < UNIT_SIZE * 0.5) {
            // 如果目标位置有其他立方体，堆叠在上方或下方
            if (dir > 0) {
              finalY = cube.position.y - UNIT_SIZE;
            } else {
              finalY = cube.position.y + UNIT_SIZE;
            }
          }
        });
        
        selected.position.y = Math.round(finalY / UNIT_SIZE) * UNIT_SIZE;
        // 确保Y坐标至少为UNIT_SIZE/2（底部在平面上）
        if (selected.position.y < UNIT_SIZE / 2) {
          selected.position.y = UNIT_SIZE / 2;
        }
      };

      const createCube = (idx) => {
        const geo = new THREE.BoxGeometry(UNIT_SIZE, UNIT_SIZE, UNIT_SIZE);
        
        // 更鲜亮但柔和的配色方案（高饱和度但降低亮度）
        const brightSoftColors = [
          0xFF9AA2, 0xFFB3BA, 0xFFC8C8, 0xFFD6A5, 0xFFE5B4,
          0xFFF4C4, 0xE8F5C8, 0xC8E6C9, 0xB8E6D1, 0xB8E0E6,
          0xC8E0F0, 0xD6E3F0, 0xE3D6F0, 0xF0D6E3, 0xF5D6E8,
          0xFFB8D1, 0xFFC8E0, 0xFFD8E8, 0xFFE8F0, 0xFFF0F8,
          0xF0E8FF, 0xE0D8FF, 0xD0C8FF, 0xC8D0FF, 0xD0E0FF,
          0xD8F0FF, 0xE0F8FF, 0xE8FFF8, 0xF0FFF0, 0xF8FFF8
        ];
        
        const colorHex = brightSoftColors[idx % brightSoftColors.length];
        
        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(colorHex),
          roughness: 0.6,
          metalness: 0.1,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.position.set(0, UNIT_SIZE / 2, 0);
        scene.add(mesh);
        cubes.push(mesh);

        const edges = new THREE.EdgesGeometry(geo);
        const line = new THREE.LineSegments(
          edges,
          new THREE.LineBasicMaterial({ color: 0x111111 })
        );
        line.position.copy(mesh.position);
        // bind line to follow mesh
        line.userData.follow = mesh;
        scene.add(line);
        cubeEdges.push(line);
      };

      const clearCubes = () => {
        cubeEdges.forEach((line) => scene.remove(line));
        cubes.forEach((c) => scene.remove(c));
        cubeEdges = [];
        cubes = [];
        if (blockOutline) {
          scene.remove(blockOutline);
          blockOutline = null;
        }
      };

      const jitterAroundCenter = (index, total) => {
        // 优化初始化位置，使用3D网格布局，避免挤在一起
        // 确保所有立方体生成在平面上方，且位置对齐到网格（UNIT_SIZE的倍数）
        const spacing = 2; // 间距为2个单位，确保立方体之间有足够空间
        
        // 计算合适的网格尺寸，确保有足够的位置容纳所有立方体
        let gridSize = Math.ceil(Math.cbrt(total));
        // 确保总位置数 >= 立方体数量
        while (gridSize * gridSize * gridSize < total) {
          gridSize++;
        }
        
        // 计算当前立方体在3D网格中的位置
        const layer = Math.floor(index / (gridSize * gridSize));
        const layerIndex = index % (gridSize * gridSize);
        const row = Math.floor(layerIndex / gridSize);
        const col = layerIndex % gridSize;
        
        // 计算中心偏移，使立方体围绕原点分布
        const centerOffset = (gridSize - 1) * spacing / 2;
        // 确保所有坐标都是UNIT_SIZE的倍数，以便堆叠
        const x = Math.round((col - centerOffset) * spacing / UNIT_SIZE) * UNIT_SIZE;
        // Y坐标：确保至少为UNIT_SIZE/2（底部在平面上），且对齐到网格
        const y = Math.max(UNIT_SIZE / 2, Math.round((layer * spacing + UNIT_SIZE / 2) / UNIT_SIZE) * UNIT_SIZE);
        const z = Math.round((row - centerOffset) * spacing / UNIT_SIZE) * UNIT_SIZE;
        
        return new THREE.Vector3(x, y, z);
      };

      const generateCubes = (n) => {
        clearCubes();
        defaultPositions = []; // 清空默认位置
        for (let i = 0; i < n; i++) {
          createCube(i);
          const defaultPos = jitterAroundCenter(i, n);
          cubes[i].position.copy(defaultPos);
          cubeEdges[i].position.copy(cubes[i].position);
          // 保存默认位置
          defaultPositions.push(defaultPos.clone());
        }
        setStatus(`已生成 ${n} 个立方体`);
        updateBlockOutline();
      };

      const autoArrange = () => {
        // 还原到默认位置
        if (defaultPositions.length === 0 || defaultPositions.length !== cubes.length) {
          setStatus("没有可还原的默认位置");
          return;
        }
        defaultPositions.forEach((pos, i) => {
          if (!cubes[i]) return;
          cubes[i].position.copy(pos);
          cubeEdges[i].position.copy(cubes[i].position);
        });
        updateBlockOutline();
        setStatus("已还原到默认位置");
      };

      const updateBlockOutline = () => {
        cubeEdges.forEach((line, i) => {
          const follow = line.userData.follow;
          if (follow) line.position.copy(follow.position);
        });
        const positions = cubes.map((c) => [c.position.x, c.position.y, c.position.z]);
        let dims = null;
        if (window.pyIsTightBlock) {
          const d = window.pyIsTightBlock(positions, UNIT_SIZE);
          dims = d?.toJs ? d.toJs() : d;
        }
        if (dims && Array.isArray(dims)) {
          const pts = cubes.map((c) => c.position.clone());
          const min = new THREE.Vector3(+Infinity, +Infinity, +Infinity);
          const max = new THREE.Vector3(-Infinity, -Infinity, -Infinity);
          pts.forEach((p) => {
            min.min(p);
            max.max(p);
          });
          // convert centers to outer bounds by ± UNIT_SIZE/2
          min.addScalar(-UNIT_SIZE / 2);
          max.addScalar(UNIT_SIZE / 2);
          // Create or update outline
          if (!blockOutline) {
            const boxGeo = new THREE.BoxGeometry(
              max.x - min.x,
              max.y - min.y,
              max.z - min.z
            );
            const edges = new THREE.EdgesGeometry(boxGeo);
            blockOutline = new THREE.LineSegments(
              edges,
              new THREE.LineBasicMaterial({ color: 0x10b981 }) // emerald-500
            );
            blockOutline.position.set(
              (min.x + max.x) / 2,
              (min.y + max.y) / 2,
              (min.z + max.z) / 2
            );
            scene.add(blockOutline);
          } else {
            // replace geometry and position
            blockOutline.geometry.dispose();
            const boxGeo = new THREE.BoxGeometry(
              max.x - min.x,
              max.y - min.y,
              max.z - min.z
            );
            const edges = new THREE.EdgesGeometry(boxGeo);
            blockOutline.geometry = edges;
            blockOutline.position.set(
              (min.x + max.x) / 2,
              (min.y + max.y) / 2,
              (min.z + max.z) / 2
            );
          }
        } else {
          if (blockOutline) {
            scene.remove(blockOutline);
            blockOutline = null;
          }
        }
      };

      const animate = () => {
        requestAnimationFrame(animate);
        // keep edge lines bound to cubes
        cubeEdges.forEach((line) => {
          const follow = line.userData.follow;
          if (follow) line.position.copy(follow.position);
        });
        controls.update();
        renderer.render(scene, camera);
      };

      // UI events
      const handleGenerate = () => {
        const n = parseInt(inputN.value, 10);
        if (!Number.isInteger(n) || n <= 0) {
          setStatus("请输入大于 0 的整数");
          return;
        }
        generateCubes(n);
      };
      btnGenerate.addEventListener("click", handleGenerate);
      btnGenerate.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") handleGenerate();
      });
      btnArrange.addEventListener("click", autoArrange);
      btnArrange.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") autoArrange();
      });
      document.addEventListener("keydown", (e) => {
        if (selected) {
          if (e.key === "ArrowUp") {
            selected.position.y += UNIT_SIZE;
          } else if (e.key === "ArrowDown") {
            selected.position.y -= UNIT_SIZE;
          }
        }
      });

      // Expose for Python usage if needed
      window.generateCubes = generateCubes;
      window.autoArrange = autoArrange;
      window.UNIT_SIZE_JS = UNIT_SIZE;

      // Start
      initScene();
      generateCubes(parseInt(inputN.value, 10));
      setStatus("提示：拖拽可在X、Y、Z轴同时移动（每次1单位），松开后自动吸附");
    </script>
  </body>
</html>
